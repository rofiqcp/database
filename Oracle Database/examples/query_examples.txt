# Oracle Database Query Examples

This file contains common Oracle SQL queries for the learning module.

## Basic SELECT Queries

### Get all items
```sql
SELECT * FROM items;
```

### Get items ordered by price (descending)
```sql
SELECT * FROM items ORDER BY price DESC;
```

### Get items with pagination (Oracle 12c+)
```sql
SELECT * FROM items
ORDER BY created_at DESC
OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY;
```

### Get items with pagination (pre-12c using ROWNUM)
```sql
SELECT * FROM (
  SELECT t.*, ROWNUM rn FROM items t WHERE ROWNUM <= 20
) WHERE rn > 10;
```

## Filtering Queries

### Get items by category
```sql
SELECT * FROM items WHERE category = 'Electronics';
```

### Get items in price range
```sql
SELECT * FROM items WHERE price BETWEEN 20 AND 100;
```

### Search items by name (case-insensitive)
```sql
SELECT * FROM items WHERE LOWER(name) LIKE '%laptop%';
```

### Get items with low stock
```sql
SELECT * FROM items WHERE quantity < 10;
```

## Aggregate Queries

### Count total items
```sql
SELECT COUNT(*) AS total_items FROM items;
```

### Get total value of inventory
```sql
SELECT SUM(price * quantity) AS total_value FROM items;
```

### Get average price by category
```sql
SELECT category, AVG(price) AS avg_price, COUNT(*) AS item_count
FROM items
GROUP BY category;
```

### Get most expensive item
```sql
SELECT * FROM items ORDER BY price DESC FETCH FIRST 1 ROW ONLY;
```

### Get most expensive item (pre-12c)
```sql
SELECT * FROM items WHERE price = (SELECT MAX(price) FROM items);
```

## INSERT Queries

### Insert single item
```sql
INSERT INTO items (name, description, category, price, quantity)
VALUES ('New Item', 'Description here', 'Category', 99.99, 10);
COMMIT;
```

### Insert using sequence directly
```sql
INSERT INTO items (id, name, description, category, price, quantity)
VALUES (items_seq.NEXTVAL, 'Item', 'Description', 'Category', 10.00, 5);
COMMIT;
```

### Insert with RETURNING clause
```sql
DECLARE
  v_id NUMBER;
BEGIN
  INSERT INTO items (name, price, quantity)
  VALUES ('New Item', 29.99, 10)
  RETURNING id INTO v_id;
  DBMS_OUTPUT.PUT_LINE('New item ID: ' || v_id);
  COMMIT;
END;
/
```

### Insert multiple items (INSERT ALL)
```sql
INSERT ALL
  INTO items (name, description, category, price, quantity) VALUES ('Item 1', 'Desc 1', 'Cat A', 10.00, 5)
  INTO items (name, description, category, price, quantity) VALUES ('Item 2', 'Desc 2', 'Cat B', 20.00, 10)
  INTO items (name, description, category, price, quantity) VALUES ('Item 3', 'Desc 3', 'Cat A', 30.00, 15)
SELECT 1 FROM DUAL;
COMMIT;
```

## UPDATE Queries

### Update single item
```sql
UPDATE items
SET price = 89.99, quantity = 20, updated_at = SYSTIMESTAMP
WHERE id = 1;
COMMIT;
```

### Update all items in a category (10% discount)
```sql
UPDATE items
SET price = price * 0.9, updated_at = SYSTIMESTAMP
WHERE category = 'Electronics';
COMMIT;
```

### Update with NVL (handle NULLs)
```sql
UPDATE items
SET description = NVL(description, 'No description available'),
    updated_at = SYSTIMESTAMP
WHERE description IS NULL;
COMMIT;
```

## DELETE Queries

### Delete single item
```sql
DELETE FROM items WHERE id = 1;
COMMIT;
```

### Delete items with zero quantity
```sql
DELETE FROM items WHERE quantity = 0;
COMMIT;
```

### Delete old items
```sql
DELETE FROM items
WHERE created_at < SYSTIMESTAMP - INTERVAL '1' YEAR;
COMMIT;
```

## Advanced Queries

### Full-text search (multiple columns)
```sql
SELECT * FROM items
WHERE LOWER(name) LIKE '%search%' OR LOWER(description) LIKE '%search%';
```

### Get items created today
```sql
SELECT * FROM items
WHERE TRUNC(created_at) = TRUNC(SYSDATE);
```

### Complex filtering
```sql
SELECT * FROM items
WHERE category IN ('Electronics', 'Furniture')
  AND price > 50
  AND quantity > 0
ORDER BY price ASC;
```

### Subquery - items above average price
```sql
SELECT * FROM items
WHERE price > (SELECT AVG(price) FROM items);
```

### CASE expression
```sql
SELECT name, price,
  CASE
    WHEN price < 25 THEN 'Budget'
    WHEN price BETWEEN 25 AND 100 THEN 'Mid-Range'
    ELSE 'Premium'
  END AS price_tier
FROM items;
```

### DECODE (Oracle-specific)
```sql
SELECT name,
  DECODE(category,
    'Electronics', 'Tech',
    'Furniture', 'Home',
    'Books', 'Education',
    'Other'
  ) AS category_group
FROM items;
```

## Oracle-Specific Queries

### Using DUAL table
```sql
SELECT SYSDATE FROM DUAL;
SELECT SYSTIMESTAMP FROM DUAL;
SELECT USER FROM DUAL;
SELECT 1 + 1 AS result FROM DUAL;
```

### Using NVL and NVL2
```sql
-- NVL: Replace NULL with default
SELECT name, NVL(description, 'No description') AS description FROM items;

-- NVL2: If not null use first, if null use second
SELECT name, NVL2(category, category, 'Uncategorized') AS category FROM items;
```

### Using COALESCE (ANSI standard)
```sql
SELECT name, COALESCE(description, category, 'N/A') AS info FROM items;
```

### Hierarchical queries (CONNECT BY)
```sql
-- Generate numbers 1-10
SELECT LEVEL AS num FROM DUAL CONNECT BY LEVEL <= 10;

-- Generate dates for next 7 days
SELECT TRUNC(SYSDATE) + LEVEL - 1 AS day_date
FROM DUAL
CONNECT BY LEVEL <= 7;
```

### Analytic functions
```sql
-- Row number per category
SELECT name, category, price,
  ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC) AS rank_in_category
FROM items;

-- Running total
SELECT name, price,
  SUM(price) OVER (ORDER BY created_at) AS running_total
FROM items;

-- Rank items by price
SELECT name, price,
  RANK() OVER (ORDER BY price DESC) AS price_rank,
  DENSE_RANK() OVER (ORDER BY price DESC) AS dense_rank
FROM items;
```

## Sequence Operations

### Get next value
```sql
SELECT items_seq.NEXTVAL FROM DUAL;
```

### Get current value
```sql
SELECT items_seq.CURRVAL FROM DUAL;
```

### Reset sequence
```sql
-- Drop and recreate
DROP SEQUENCE items_seq;
CREATE SEQUENCE items_seq START WITH 1 INCREMENT BY 1;
```

## Index Operations

### Create indexes
```sql
CREATE INDEX idx_items_category ON items(category);
CREATE INDEX idx_items_price ON items(price);
CREATE INDEX idx_items_name ON items(name);
```

### Create composite index
```sql
CREATE INDEX idx_items_cat_price ON items(category, price);
```

### View indexes
```sql
SELECT index_name, column_name FROM user_ind_columns
WHERE table_name = 'ITEMS'
ORDER BY index_name, column_position;
```

### Drop index
```sql
DROP INDEX idx_items_price;
```

## Table Management

### View table schema
```sql
DESC items;
-- Or
SELECT column_name, data_type, data_length, nullable
FROM user_tab_columns
WHERE table_name = 'ITEMS'
ORDER BY column_id;
```

### Get database objects
```sql
SELECT object_name, object_type FROM user_objects
ORDER BY object_type, object_name;
```

### Get table size
```sql
SELECT segment_name, bytes/1024/1024 AS size_mb
FROM user_segments
WHERE segment_name = 'ITEMS';
```

### Analyze table statistics
```sql
EXEC DBMS_STATS.GATHER_TABLE_STATS(USER, 'ITEMS');

SELECT num_rows, blocks, avg_row_len
FROM user_tables
WHERE table_name = 'ITEMS';
```

## Transaction Examples

### Basic transaction
```sql
BEGIN
  INSERT INTO items (name, price, quantity) VALUES ('Item A', 10.00, 5);
  UPDATE items SET quantity = quantity - 1 WHERE id = 2;
  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END;
/
```

### Savepoint example
```sql
SAVEPOINT before_delete;

DELETE FROM items WHERE category = 'Test';
-- Oops, wrong category!

ROLLBACK TO before_delete;
-- Data restored

COMMIT;
```

## PL/SQL Examples

### Anonymous block
```sql
DECLARE
  v_count NUMBER;
  v_total NUMBER;
BEGIN
  SELECT COUNT(*), SUM(price * quantity)
  INTO v_count, v_total
  FROM items;

  DBMS_OUTPUT.PUT_LINE('Total items: ' || v_count);
  DBMS_OUTPUT.PUT_LINE('Total value: $' || TO_CHAR(NVL(v_total, 0), '999,999.99'));
END;
/
```

### Cursor example
```sql
DECLARE
  CURSOR c_items IS
    SELECT name, price FROM items WHERE price > 100 ORDER BY price DESC;
  v_name items.name%TYPE;
  v_price items.price%TYPE;
BEGIN
  OPEN c_items;
  LOOP
    FETCH c_items INTO v_name, v_price;
    EXIT WHEN c_items%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_name || ': $' || v_price);
  END LOOP;
  CLOSE c_items;
END;
/
```

### FOR loop cursor (simplified)
```sql
BEGIN
  FOR rec IN (SELECT name, price FROM items ORDER BY price DESC) LOOP
    DBMS_OUTPUT.PUT_LINE(rec.name || ': $' || rec.price);
  END LOOP;
END;
/
```

## Backup and Export

### Export using Data Pump (command line)
```bash
expdp system/oracle@XEPDB1 tables=items directory=DATA_PUMP_DIR dumpfile=items.dmp
```

### Import using Data Pump
```bash
impdp system/oracle@XEPDB1 tables=items directory=DATA_PUMP_DIR dumpfile=items.dmp
```

## Performance Tips

1. **Use bind variables** to enable query plan reuse
2. **Create indexes** on frequently searched columns
3. **Use EXPLAIN PLAN** to analyze query performance
4. **Gather statistics** with DBMS_STATS periodically
5. **Avoid SELECT *** in production, specify columns
6. **Use connection pooling** to reduce connection overhead
7. **Commit periodically** in bulk operations
8. **Use bulk operations** (FORALL, BULK COLLECT) for large datasets

## Common Oracle Functions

### String functions
```sql
SELECT UPPER(name), LOWER(category), LENGTH(description) FROM items;
SELECT SUBSTR(name, 1, 10), TRIM(name), REPLACE(name, 'old', 'new') FROM items;
SELECT INSTR(name, 'a'), LPAD(name, 30, '*'), RPAD(name, 30, '-') FROM items;
```

### Date functions
```sql
SELECT SYSDATE, SYSTIMESTAMP FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') AS formatted_date FROM DUAL;
SELECT ADD_MONTHS(SYSDATE, 3) AS three_months_later FROM DUAL;
SELECT MONTHS_BETWEEN(SYSDATE, created_at) AS months_old FROM items;
SELECT TRUNC(SYSDATE, 'MM') AS first_of_month FROM DUAL;
```

### Math functions
```sql
SELECT ROUND(price, 2), CEIL(price), FLOOR(price), ABS(quantity - 10) FROM items;
SELECT MOD(quantity, 3), POWER(price, 2), SQRT(price) FROM items;
```

### Conversion functions
```sql
SELECT TO_NUMBER('123.45') FROM DUAL;
SELECT TO_CHAR(1234.5, '$9,999.99') FROM DUAL;
SELECT TO_DATE('2024-01-15', 'YYYY-MM-DD') FROM DUAL;
```

## Notes

- Oracle SQL is case-insensitive for keywords but case-sensitive for string comparisons
- Use LOWER() or UPPER() for case-insensitive string comparisons
- Always COMMIT after DML operations (INSERT, UPDATE, DELETE)
- Use bind variables to prevent SQL injection and improve performance
- Oracle uses sequences (or IDENTITY columns in 12c+) for auto-increment
- The DUAL table is used for selecting constants and expressions
- NVL() is Oracle-specific; COALESCE() is the ANSI standard equivalent
