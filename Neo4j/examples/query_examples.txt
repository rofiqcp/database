# Neo4j Cypher Query Examples
# 50+ example queries for the Neo4j Learning Module

# ========================================
# BASIC NODE OPERATIONS (1-10)
# ========================================

# 1. Create a single item
CREATE (i:Item {
  id: 'item-001',
  name: 'Laptop',
  description: 'High-performance laptop',
  price: 999.99,
  stock: 10,
  createdAt: datetime(),
  updatedAt: datetime()
})
RETURN i

# 2. Create item with category relationship
CREATE (i:Item {id: 'item-002', name: 'Mouse', price: 29.99, stock: 50})
MERGE (c:Category {id: 'cat-001', name: 'Electronics'})
CREATE (i)-[:BELONGS_TO]->(c)
RETURN i, c

# 3. Create item with multiple tags
CREATE (i:Item {id: 'item-003', name: 'Keyboard', price: 89.99, stock: 30})
MERGE (t1:Tag {id: 'tag-001', name: 'tech'})
MERGE (t2:Tag {id: 'tag-002', name: 'gaming'})
CREATE (i)-[:HAS_TAG]->(t1)
CREATE (i)-[:HAS_TAG]->(t2)
RETURN i, t1, t2

# 4. Find all items
MATCH (i:Item)
RETURN i

# 5. Find item by ID
MATCH (i:Item {id: 'item-001'})
RETURN i

# 6. Find items by name (exact match)
MATCH (i:Item {name: 'Laptop'})
RETURN i

# 7. Find items with name containing text
MATCH (i:Item)
WHERE i.name CONTAINS 'Laptop'
RETURN i

# 8. Find items by price range
MATCH (i:Item)
WHERE i.price >= 100 AND i.price <= 500
RETURN i.name, i.price
ORDER BY i.price

# 9. Count all items
MATCH (i:Item)
RETURN count(i) as totalItems

# 10. Get items ordered by creation date
MATCH (i:Item)
RETURN i
ORDER BY i.createdAt DESC

# ========================================
# UPDATE OPERATIONS (11-15)
# ========================================

# 11. Update item properties
MATCH (i:Item {id: 'item-001'})
SET i.price = 899.99,
    i.stock = 15,
    i.updatedAt = datetime()
RETURN i

# 12. Update multiple items at once
MATCH (i:Item)
WHERE i.stock < 10
SET i.stock = 20
RETURN count(i) as updated

# 13. Add property to existing nodes
MATCH (i:Item)
SET i.featured = false
RETURN count(i)

# 14. Remove property from nodes
MATCH (i:Item)
REMOVE i.featured
RETURN count(i)

# 15. Increment stock value
MATCH (i:Item {id: 'item-001'})
SET i.stock = i.stock + 10
RETURN i

# ========================================
# DELETE OPERATIONS (16-20)
# ========================================

# 16. Delete item by ID (with relationships)
MATCH (i:Item {id: 'item-001'})
DETACH DELETE i

# 17. Delete items by criteria
MATCH (i:Item)
WHERE i.price < 10
DETACH DELETE i

# 18. Delete orphaned categories (no items)
MATCH (c:Category)
WHERE NOT (c)<-[:BELONGS_TO]-()
DELETE c

# 19. Delete orphaned tags (no items)
MATCH (t:Tag)
WHERE NOT (t)<-[:HAS_TAG]-()
DELETE t

# 20. Delete all data (careful!)
MATCH (n)
DETACH DELETE n

# ========================================
# RELATIONSHIP OPERATIONS (21-30)
# ========================================

# 21. Create relationship between existing nodes
MATCH (i:Item {id: 'item-001'})
MATCH (c:Category {name: 'Electronics'})
CREATE (i)-[:BELONGS_TO]->(c)

# 22. Create or update relationship (MERGE)
MATCH (i:Item {id: 'item-001'})
MERGE (c:Category {name: 'Electronics'})
MERGE (i)-[:BELONGS_TO]->(c)

# 23. Find items with specific category
MATCH (i:Item)-[:BELONGS_TO]->(c:Category {name: 'Electronics'})
RETURN i.name, i.price

# 24. Find items with specific tag
MATCH (i:Item)-[:HAS_TAG]->(t:Tag {name: 'tech'})
RETURN i.name

# 25. Find items with multiple tags (AND)
MATCH (i:Item)-[:HAS_TAG]->(t1:Tag {name: 'tech'})
MATCH (i)-[:HAS_TAG]->(t2:Tag {name: 'gaming'})
RETURN i.name

# 26. Find items with any of multiple tags (OR)
MATCH (i:Item)-[:HAS_TAG]->(t:Tag)
WHERE t.name IN ['tech', 'gaming']
RETURN DISTINCT i.name

# 27. Remove specific relationship
MATCH (i:Item {id: 'item-001'})-[r:BELONGS_TO]->()
DELETE r

# 28. Change item's category
MATCH (i:Item {id: 'item-001'})-[r:BELONGS_TO]->()
DELETE r
WITH i
MATCH (c:Category {name: 'NewCategory'})
CREATE (i)-[:BELONGS_TO]->(c)

# 29. Add tag to item if not exists
MATCH (i:Item {id: 'item-001'})
MERGE (t:Tag {name: 'new-tag'})
MERGE (i)-[:HAS_TAG]->(t)

# 30. Remove all tags from item
MATCH (i:Item {id: 'item-001'})-[r:HAS_TAG]->()
DELETE r

# ========================================
# AGGREGATION QUERIES (31-40)
# ========================================

# 31. Count items per category
MATCH (c:Category)<-[:BELONGS_TO]-(i:Item)
RETURN c.name as category, count(i) as itemCount
ORDER BY itemCount DESC

# 32. Average price by category
MATCH (c:Category)<-[:BELONGS_TO]-(i:Item)
RETURN c.name as category, avg(i.price) as avgPrice
ORDER BY avgPrice DESC

# 33. Total stock value by category
MATCH (c:Category)<-[:BELONGS_TO]-(i:Item)
RETURN c.name as category, sum(i.price * i.stock) as totalValue
ORDER BY totalValue DESC

# 34. Min and Max prices
MATCH (i:Item)
RETURN min(i.price) as minPrice, max(i.price) as maxPrice

# 35. Items grouped by price range
MATCH (i:Item)
RETURN 
  CASE
    WHEN i.price < 50 THEN 'Budget'
    WHEN i.price < 200 THEN 'Mid-range'
    ELSE 'Premium'
  END as priceRange,
  count(i) as count

# 36. Tag co-occurrence (tags that appear together)
MATCH (t1:Tag)<-[:HAS_TAG]-(i:Item)-[:HAS_TAG]->(t2:Tag)
WHERE t1.name < t2.name
RETURN t1.name, t2.name, count(i) as cooccurrence
ORDER BY cooccurrence DESC
LIMIT 10

# 37. Most popular tags
MATCH (t:Tag)<-[:HAS_TAG]-(i:Item)
RETURN t.name, count(i) as itemCount
ORDER BY itemCount DESC

# 38. Items with most tags
MATCH (i:Item)-[:HAS_TAG]->(t:Tag)
RETURN i.name, count(t) as tagCount
ORDER BY tagCount DESC

# 39. Categories with highest average stock
MATCH (c:Category)<-[:BELONGS_TO]-(i:Item)
RETURN c.name, avg(i.stock) as avgStock
ORDER BY avgStock DESC

# 40. Total items, categories, and tags
MATCH (i:Item)
WITH count(i) as items
MATCH (c:Category)
WITH items, count(c) as categories
MATCH (t:Tag)
RETURN items, categories, count(t) as tags

# ========================================
# GRAPH TRAVERSAL & PATTERNS (41-50)
# ========================================

# 41. Find items related through shared tags
MATCH (i:Item {name: 'Laptop'})-[:HAS_TAG]->(t:Tag)<-[:HAS_TAG]-(related:Item)
WHERE i <> related
RETURN DISTINCT related.name, collect(t.name) as sharedTags

# 42. Find items in same category
MATCH (i:Item {name: 'Laptop'})-[:BELONGS_TO]->(c:Category)<-[:BELONGS_TO]-(related:Item)
WHERE i <> related
RETURN related.name, c.name

# 43. Find similar items (same category OR shared tags)
MATCH (i:Item {name: 'Laptop'})
OPTIONAL MATCH (i)-[:HAS_TAG]->(t:Tag)<-[:HAS_TAG]-(similar1:Item)
OPTIONAL MATCH (i)-[:BELONGS_TO]->(c:Category)<-[:BELONGS_TO]-(similar2:Item)
WITH i, collect(DISTINCT similar1) + collect(DISTINCT similar2) as similar
UNWIND similar as item
WHERE item IS NOT NULL AND item <> i
RETURN DISTINCT item.name

# 44. Shortest path between two items
MATCH (i1:Item {name: 'Laptop'}), (i2:Item {name: 'Mouse'})
MATCH path = shortestPath((i1)-[*]-(i2))
RETURN path, length(path) as pathLength

# 45. All paths between items (limited depth)
MATCH (i1:Item {name: 'Laptop'}), (i2:Item {name: 'Mouse'})
MATCH path = (i1)-[*..4]-(i2)
RETURN path
LIMIT 5

# 46. Find items within 2 hops
MATCH (i:Item {name: 'Laptop'})-[*1..2]-(connected)
WHERE connected:Item
RETURN DISTINCT connected.name

# 47. Recommend items based on shared tags (weighted)
MATCH (i:Item {name: 'Laptop'})-[:HAS_TAG]->(t:Tag)<-[:HAS_TAG]-(rec:Item)
WHERE i <> rec
WITH rec, count(t) as sharedTags
RETURN rec.name, sharedTags
ORDER BY sharedTags DESC
LIMIT 5

# 48. Find items NOT in a category
MATCH (i:Item)
WHERE NOT (i)-[:BELONGS_TO]->(:Category)
RETURN i.name

# 49. Find items with no tags
MATCH (i:Item)
WHERE NOT (i)-[:HAS_TAG]->(:Tag)
RETURN i.name

# 50. Pattern: Items with specific tag count
MATCH (i:Item)-[:HAS_TAG]->(t:Tag)
WITH i, count(t) as tagCount
WHERE tagCount = 3
RETURN i.name, tagCount

# ========================================
# ADVANCED QUERIES (51-60)
# ========================================

# 51. Batch create items from collection
UNWIND [
  {name: 'Item 1', price: 10.99},
  {name: 'Item 2', price: 20.99},
  {name: 'Item 3', price: 30.99}
] as data
CREATE (i:Item {
  id: randomUUID(),
  name: data.name,
  price: data.price,
  stock: 0,
  createdAt: datetime()
})
RETURN count(i)

# 52. Conditional property setting
MATCH (i:Item)
SET i.status = CASE
  WHEN i.stock = 0 THEN 'Out of Stock'
  WHEN i.stock < 10 THEN 'Low Stock'
  ELSE 'In Stock'
END
RETURN i.name, i.status

# 53. List comprehension - collect tag names
MATCH (i:Item)
RETURN i.name, [(i)-[:HAS_TAG]->(t:Tag) | t.name] as tags

# 54. Map projection
MATCH (i:Item)
RETURN i {.name, .price, tagCount: size([(i)-[:HAS_TAG]->() | 1])}

# 55. Exists pattern check
MATCH (i:Item)
WHERE exists((i)-[:HAS_TAG]->(:Tag {name: 'tech'}))
RETURN i.name

# 56. Multiple pattern matching
MATCH (i:Item)-[:BELONGS_TO]->(c:Category),
      (i)-[:HAS_TAG]->(t:Tag)
RETURN i.name, c.name, collect(t.name) as tags

# 57. Optional match for null handling
MATCH (i:Item)
OPTIONAL MATCH (i)-[:BELONGS_TO]->(c:Category)
OPTIONAL MATCH (i)-[:HAS_TAG]->(t:Tag)
RETURN i.name, c.name as category, collect(t.name) as tags

# 58. Union of two queries
MATCH (i:Item)
WHERE i.price < 50
RETURN i.name, 'Cheap' as category
UNION
MATCH (i:Item)
WHERE i.price >= 50
RETURN i.name, 'Expensive' as category

# 59. Recursive category hierarchy (if implemented)
MATCH path = (c:Category)-[:SUBCATEGORY_OF*]->(parent:Category)
RETURN c.name, parent.name, length(path) as depth

# 60. Create full-text search index and query
// First create the index (run once)
CREATE FULLTEXT INDEX itemSearch IF NOT EXISTS
FOR (i:Item) ON EACH [i.name, i.description]

// Then search
CALL db.index.fulltext.queryNodes("itemSearch", "laptop gaming")
YIELD node, score
RETURN node.name, score
ORDER BY score DESC

# ========================================
# UTILITY QUERIES (61-65)
# ========================================

# 61. View database schema
CALL db.schema.visualization()

# 62. List all constraints
SHOW CONSTRAINTS

# 63. List all indexes
SHOW INDEXES

# 64. Count nodes by label
MATCH (n)
RETURN labels(n) as label, count(*) as count
ORDER BY count DESC

# 65. Database statistics
CALL db.stats.retrieve('GRAPH COUNTS')

# ========================================
# PERFORMANCE & ANALYSIS (66-70)
# ========================================

# 66. Explain query plan
EXPLAIN MATCH (i:Item {name: 'Laptop'})
RETURN i

# 67. Profile query execution
PROFILE MATCH (i:Item)-[:HAS_TAG]->(t:Tag)
RETURN i.name, collect(t.name)

# 68. Find duplicate items by name
MATCH (i:Item)
WITH i.name as name, collect(i) as items
WHERE size(items) > 1
RETURN name, size(items) as duplicates

# 69. Analyze relationship distribution
MATCH ()-[r]->()
RETURN type(r) as relationshipType, count(r) as count
ORDER BY count DESC

# 70. Find disconnected items (no relationships)
MATCH (i:Item)
WHERE NOT (i)-[]-()
RETURN i.name

